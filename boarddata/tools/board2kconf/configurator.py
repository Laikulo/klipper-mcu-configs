import re
from datetime import datetime
from os import PathLike
from pathlib import Path
from typing import Optional

from .kconfig import KConfig, KConfigChoice
from .model import BoardDefinition

FREQ_IN_RE=re.compile('([0-9]+)([MK]hz)', flags=re.IGNORECASE)

class Configurator(object):
    def __init__(self, klipper_path: PathLike, board: BoardDefinition):
        self.klipper_path = klipper_path
        self.kconfig = KConfig(klipper_path)
        self._board = board
        self.kconfig.symbol(prompt="Enable extra low-level configuration options").set(True)

    def set_arch(self, arch):
        # Arch is pretty easy to deal with, since it is always the same prompt, but the choice is unnamed
        self.kconfig.choice(prompt="Micro-controller Architecture").select(prompt=arch)

    def set_mcu(self, mcu):
        if proc_choice := self.kconfig.choice(prompt="Processor model"):
            for possible_mcu in proc_choice.choices():
                mcu_prompt = possible_mcu.nodes[0].prompt[0].split(' ')[0]
                if mcu_prompt == mcu:
                    possible_mcu.set_value(2)
        else:
            # This arch doesn't support setting the MCU
            if not mcu:
                # We don't care
                return
            # If the kconfig sets an 'MCU', and it is already correct, don't mess with it
            if mcu_sym := self.kconfig.symbol(name="MCU", allow_invisible=True):
                if mcu_sym.get() == mcu:
                    return
            raise RuntimeError(f'Could not set MCU type to {mcu}. Is it supported by this version of klipper?')

    def set_freq(self, freq):
        freq_choice: Optional[KConfigChoice] = None
        for choice in self.kconfig.choices:
            if choice.prompt in ["Processor Speed", "Clock Reference"]:
                freq_choice = choice
                break
        if (not freq_choice) and freq:
            raise ValueError('Frequency cannot be set for this MCU')
        # Special case "INTERNAL"
        if freq == "INTERNAL":
            freq_choice.select(prompt="Internal Clock")
            return
        # Frequency should be in the form XXMhz or XXKhz
        if matches := FREQ_IN_RE.match(freq):
            rate, units = matches.groups()
        else:
            raise ValueError(f'Frequency "{freq}" not recognized')
        target_re = re.compile(f'^{re.escape(rate)} ?{re.escape(units)}',flags=re.IGNORECASE)
        for sym in freq_choice.choices():
            if target_re.match(sym.nodes[0].prompt[0]):
                sym.set_value(2)
                return
        raise ValueError(f'Could not set frequency to {freq}')

    def _header(self):
        return \
            "#\n" \
            "#-# This file was generated by TBDNAMEHERE.\n" \
            f"#-# This config is for: {self._board.manufacturer}/{self._board.model}/{self._board.variant}\n" \
            f"#-# This config was generated at {datetime.now(None).isoformat()}\n" \
            "#-# THIS IS WIP SOFTWARE, AND IT MAY EAT YOUR CAT. BE CAREFUL. TRUST (or not) BUT VERIFY\n" \
            "#\n"

    def save_config(self, config_path:PathLike):
        self.kconfig.kcl.write_config(str(Path(config_path).absolute()), header=self._header(), save_old=False)
